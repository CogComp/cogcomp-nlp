/**
 * This software is released under the University of Illinois/Research and Academic Use License. See
 * the LICENSE file in the root folder for details. Copyright (c) 2016
 *
 * Developed by: The Cognitive Computation Group University of Illinois at Urbana-Champaign
 * http://cogcomp.cs.illinois.edu/
 */
/**
 * 
 */
package edu.illinois.cs.cogcomp.ner;

import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;

/**
 * <p>This class will run the NER's "benchmark.sh" in any subdirectory starting with "r.".
 * These directories are generated by a set of scripts that change the default learning
 * rate and thickness in the LBJ file in a copied subdirectory containing source code
 * for the cogcomp system. </p>
 * 
 * <p>It will take one argument that indicates the number of processes to spawn. Each 
 * benchmark.sh might take considerable memory, so the default (the number of cores on
 * the machine) might be too much.</p>
 * @author redman
 */
public class ParameterSweep {

	/**
	 * Control the processes running various benchmarks.
	 * @param args
	 * @throws IOException 
	 */
	public static void main(String[] args) throws IOException {
		int processCount = Runtime.getRuntime().availableProcessors();
		if (args.length > 0) {
			try {
				processCount = Integer.parseInt(args[0]);
			} catch (Throwable t) {
				System.err.println("The only allowable argument is the number of processes to spawn, must be an integer : "+args[0]);
				System.exit(-1);
			}
		}
		System.out.println("Running a maximum of "+processCount+" processes");
		// get and init the process array.
		Process[] processes = new Process[processCount];
		for (int i = 0; i < processCount; i++) processes[i] = null;
		
		// get the directories to run benchmarks in
		File[] directories = new File(".").listFiles(new FilenameFilter() {
			@Override
			public boolean accept(File dir, String name) {
				return name.startsWith("r.");
			}
		});
		
		// used to construct the executable.
		final String benchmarkDirectory = "ner/";
		final String benchmarkExecutable = "./scripts"+File.separator+"benchmarks.sh";
		
		// Do it.
		for (File directory : directories) {
			int next = -1;
			while(next == -1) {
				for (int i = 0; i < processCount; i++) {
					Process process = processes[i];
					if (process == null || !process.isAlive()) {
						if (process != null) System.out.println("Completed : "+process.toString());
						processes[i] = null;
						next = i;
					}
				}
			}
			
			// we have an available process slot.
			String fullpath = directory.getCanonicalPath()+File.separator+benchmarkDirectory;
			Process newprocess = null;
			try {
				// set up arguments.
				File workingdir = new File(fullpath);
				File outputfile = new File(workingdir, "results.out");
				File errfile = new File(workingdir, "errors.out");
				
				// set up and run process
				ProcessBuilder pb = new ProcessBuilder(benchmarkExecutable, "-training");
				pb.redirectOutput(outputfile);
				pb.redirectError(errfile);
				pb.directory(workingdir);
				newprocess = pb.start();
				System.out.println("Started command \""+benchmarkExecutable+"\" in \""+workingdir.getCanonicalPath()+"\"");
			} catch (IOException e) {
				e.printStackTrace();
				System.err.println("Can not start the executable, will abort : \""+benchmarkExecutable+"\"");
				System.exit(-1);
			}
			processes[next] = newprocess;
		}
		
		// wait for them all to complete.
		System.out.println("Waiting for all to finish...");
		while(true) {
			int count = processCount;
			for (int i = 0; i < processCount; i++) {
				Process process = processes[i];
				if (process == null || !process.isAlive()) {
					count--;
					if (process != null) System.out.println("Completed : "+process.toString());
					processes[i] = null;
				}
			}
			if (count == 0)  {
				System.out.println("Done");
				break;
			}
		}
	}
}
